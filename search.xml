<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[phpstorm 配置sass 自动编译css]]></title>
    <url>%2F2017%2F07%2F24%2Fphpstorm-sass%2F</url>
    <content type="text"><![CDATA[1. 点击phpstorm 左上角 File-&gt;Settings进入后点击-&gt;File-watchers 如下 2. 点击右上角绿色的+号创建一个sass 如下 最后一步 点击ok完成操作 现在可以去编译你的sass啦 自动编译生成css 在当前目录下 指定OutPut路径 默认是在当前目录下 1Arguments: --no-cache --update $FileName$**填写你的路径**:$FileNameWithoutExtension$.css 注! 配置前需要先安装ruby 和sass]]></content>
  </entry>
  <entry>
    <title><![CDATA[Animate.css]]></title>
    <url>%2F2017%2F07%2F24%2FAnimate%2F</url>
    <content type="text"><![CDATA[Animate.css是一个有趣的，跨浏览器的css3动画库。很值得我们在项目中引用。 插件描述: Animate.css内置了很多典型的css3动画，兼容性好使用方便。 Animate.css 官方网站 一. 基本用法 1.在您的文档中包含样式表 < link rel = “ stylesheet ” href = “ animate.min.css ” > 或使用由CDNJS托管的版本 &lt; head &gt; &lt; link rel = “stylesheet” href = “ https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.5.2/animate.min.css” &gt;&lt; /head &gt;用法 要在您的网站中使用animate.css，只需将样式表拖放到文档中，并将该类添加animated到元素，以及任何动画名称 例 : 弹跳效果 2.将类添加animated到要动画的元素中。您可能还希望将类包含在infinite无限循环中。 例: 无限弹跳效果 注意 : 使用时动画名称前 必须加 animated 类方可生效 最后，您需要添加以下类之一: Attention Seekers 注意力寻求者（9个） 样式 简介 bounce 弹跳 flash 闪 pulse 脉冲 rubberBand 橡皮筋 shake 摇 swing 摇摆 tada 波幅 wobble 摇晃 jello 果冻 Bouncing Entrances 弹跳进入（5个） 样式 简介 bounceIn 向里，弹跳 bounceInDown 向里，向下,弹跳 bounceInLeft 向里，向左,弹跳 bounceInRight 向里，向右,弹跳 bounceInUp 向里，向上，弹跳 Bouncing Exits 弹跳出口（5个） 样式 简介 bounceOut 向外，弹跳 bounceOutDown 向外，向下，弹跳 bounceOutLeft 向里，向左，弹跳 bounceOutRight 向外，向右，弹跳 bounceOutUp 向外，各上，弹跳 Fading Entrances 平淡进入（9个） 样式 简介 fadeIn 向里 fadeInDown 向里，向下，变大 fadeInDownBig 向里，向左，弹跳 fadeInLeft 向里，向左 fadeInLeftBig 向里，向左，变大 fadeInRight 向里，向右 fadeInRightBig 向里，向右，变大 fadeInUp 向里，向上 fadeInUpBig 向里，向上，变大 Fading Exits 平淡退场（9个） 样式 简介 fadeOut 向外 fadeOutDown 向外，向下 fadeOutDownBig 向外，向下，变大 fadeOutLeft 向外，向左 fadeOutLeftBig 向外，向左，变大 fadeOutRight 向外，向右 fadeOutRightBig 向外，向右，变大 fadeOutUp 向外，向上 fadeOutUpBig 向外，向上，变大 Flippers 翻动 （5个） 样式 简介 flip 翻翻动转 flipInX 向里，上下，翻动 flipInY 向里，左右，翻动 flipOutX 向外，上下，翻动 flipOutY 向外，左右，翻动 Lightspeed 缓缓移动 （2个） 样式 简介 lightSpeedIn 缓缓移入 lightSpeedOut 缓缓移出 Rotating Entrances 翻转入口 （5个） 样式 简介 rotateIn 向里，翻转 rotateInDownLeft 向里，向下，向左，翻转 rotateInDownRight 向里，向下，向右，翻转 rotateInUpLeft 向里，向上，向左，翻转 rotateInUpRight 向里，向上，向右，翻转 Rotating Exits 翻转退场 （5个） 样式 简介 rotateOut 向外，翻转 rotateOutDownLeft 向外，向下，向右，翻转 rotateOutDownRight 向外，向下，向右，翻转 rotateOutUpLeft 向外，向上，向左，翻转 rotateOutUpRight 向外，向上，向右，翻转 Specials （3个） 样式 简介 hinge 合页 rollIn 向里滚动 rollOut 向外滚动 Zoom Entrances 缩放进入 （5个） 样式 简介 zoomIn 向里，放大 zoomInDown 向里，向下，放大 zoomInLeft 向里，向左，放大 zoomInRight 向外，向右，放大 zoomInUp 向里，向上，放大 Zoom Exits 缩放退场 （5个） 样式 简介 zoomOut 向外，放大 zoomOutDown 向外，向下，放大 zoomOutLeft 向外，向左，放大 zoomOutRight 向外，向右，放大 zoomOutUp 向外，向上，放大 Sliding Entrances 滑动进入 （4个） 样式 简介 slideInUp 向里，向上，滑动 slideInDown 向里，向下，滑动 slideInLeft 向里，向左，滑动 slideInRight 向里，向右，滑动 Sliding Exits 滑动退场 （4个）\ 样式 简介 slideOutUp 向外，向上，滑动 slideOutDown 向外，向下，滑动 slideOutLeft 向外，向上，滑动 slideOutRight 向外，向右，滑动 当您将其与jQuery组合或添加您自己的CSS规则时，您可以使用animate.css来完成一大堆其他内容.动态地使用jQuery轻松添加动画: $（’ #box ‘).addClass（’ animated bounceInRight ‘）; 您还可以检测动画结束的时间:您可以更改动画的持续时间，添加延迟或更改播放次数： #box{ -vendor-animation-duration：3 s ; -vendor-animation-delay：2 秒 ; -vendor-animation-iteration-count：infinite ;} animation-delay 属性定义动画何时开始。 animation-delay 值以秒或毫秒计。提示: 允许负值，-2s 使动画马上开始，但跳过 2 秒进入动画. 例: 等待俩秒 开始动画div{animation-delay:2s;-webkit-animation-delay:2s; / Safari 和 Chrome /} 关于Jquery中animate可以操作css样式属性总结 可以用 animate() 方法来操作所有 CSS 属性吗？是的，几乎可以！不过，需要记住一件重要的事情:当使用 animate()时，必须使用 Camel 标记法书写所有的属性名，比如，必须使用 paddingLeft而不是 padding-left，使用 marginRight而不是 margin-right，等等。 css中的不是所有属性都可以用jQuery动画（animate函数）来动态改变，下面总结了JQ可以操作元素的一些属性：123456789101112131415161718192021222324252627282930313233343536* backgroundPosition * borderWidth * borderBottomWidth * borderLeftWidth * borderRightWidth * borderTopWidth * borderSpacing * margin * marginBottom * marginLeft * marginRight * marginTop * outlineWidth * padding * paddingBottom * paddingLeft * paddingRight * paddingTop * height * width * maxHeight * maxWidth * minHeight * maxWidth * font * fontSize 在animate函数的css参数指定并不同于标准css属性，例如这个css标准是：font-size。同理上面很多也是这样的情况 * bottom * left * right * top * letterSpacing * wordSpacing * lineHeight * textIndent * opacity 小例子animate 结合jQuery 让指定元素点击左右移动 1234567$(&quot;#right&quot;).click(function () &#123; $(&quot;.block&quot;).animate(&#123; left: &apos;+50px&apos; &#125;, &quot;slow&quot;);&#125;);$(&quot;#left&quot;).click(function () &#123; $(&quot;.block&quot;).animate(&#123; left: &apos;-50px&apos; &#125;, &quot;slow&quot;);&#125;); 有不足之处,还请各位指出! 抱拳了,老铁! 下载地址]]></content>
  </entry>
  <entry>
    <title><![CDATA[使用Hexo+github 搭建自己的博客]]></title>
    <url>%2F2017%2F07%2F24%2Fhexo%2F</url>
    <content type="text"><![CDATA[搭建博客前期准备工作 安装Node（必须）作用:用来生成静态页面的 到Node.js官网下载相应平台的最新版本，一路安装即可。 安装Git:（必须） 作用:把本地的hexo内容提交到github上去. 申请GitHub（必须） 作用：是用来做博客的远程创库、域名、服务器之类的，怎么与本地hexo建立连接等下讲。 先来搭建一个github 1.进入github 点击创建项目 如图: -1.输入你的库名,然后点击创建 如图:（创建后） 1.把库文件克隆到本地项目中 依次按顺序输入 git clone https://github.com/gengxiaojun1/gxj.git echo "# gxj" >> README.md git init git add README.md git commit -m "first commit" git remote add origin https://github.com/gengxiaojun1/gxj.git git push -u origin master 2.现在库创建好了以后点击settings设置一直往下滑找到github pages,选择你的分支来源,例master||gh-pages,点击创建,主题先不要选,先往下走! https://gengxiaojun1.github.io/gxj/ 3.当然也可以自己买一个域名使用,Custom domain 下面就是设置自定义域名的地方. 4.关于域名配置稍后更新! 安装Hexonpm install hexo-cli -g 1.输入以下命令查看Hexo的版本信息 hexo-cli: 1.0.3 os: Linux 4.10.0-27-generic linux x64 http_parser: 2.7.0 node: 8.2.1 v8: 5.8.283.41 uv: 1.13.1 zlib: 1.2.11 ares: 1.10.1-DEV modules: 57 openssl: 1.0.2l icu: 59.1 unicode: 9.0 cldr: 31.0.1 tz: 2017b 2.初始化一个hexo博客 hexo init [项目名] 3.安装依赖包 npm install 4.文件结构 ├── _config.yml ├── node_modules ├── package.json ├── scaffolds ├── source | └── _posts └── themes 5.写一篇文章? hexo new "hello" 我们找到这个文件之后用Markdown编辑器或其他文本编辑器打开，我们会看到里面已经有内容了: --- title: Hello date: 2017-7-24 17:00:00 tags: --- 6.在---下面随便写点什么,保存 7.文章写好了怎么看效果呢？输入这条命令! hexo generate 简写 hexo g 8.页面预览下! hexo serve 简写 hexo s 我们会看到这样一条提示:复制到浏览器看看 INFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 9.部署你的git,进入到_config.yml文件中,在最后填上如下代码 deploy: type: git repo: https://github.com/gengxiaojun1/gxj.git branch: master 10.找不到git部署? ERROR Deployer not found: git 解决办法 npm install hexo-deployer-git --save 命令大合集 简写 hexo n "我的博客" == hexo new "我的博客" #新建文章 hexo p == hexo publish hexo g == hexo generate#生成 hexo s == hexo server #启动服务预览 hexo d == hexo deploy#部署 服务器 hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。 hexo server -s #静态模式 hexo server -p 5000 #更改端口 hexo server -i 192.168.1.1 #自定义 IP hexo clean #清除缓存 网页正常情况下可以忽略此条命令 hexo g #生成静态网页 hexo d #开始部署 更换主题1.如何更换主题呢? 真的是超级简单! hexo主题模板上找到你喜欢的把他clone 下来,放到themes目录里面,然后返回上一级去到,_config.yml里面 找到:theme: [模板文件名] 改完保存 hexo clean 清楚一下缓存 hexo g 生成静态网页 hexo s 预览一下 hexo d 部署到github上面]]></content>
  </entry>
  <entry>
    <title><![CDATA[Laravel-RestfulAPI 资源控制器]]></title>
    <url>%2F2017%2F07%2F24%2Flaravel-zy%2F</url>
    <content type="text"><![CDATA[laravel里有基本控制器和控制器路由。不过我们这里介绍另一种风格－－RESTFul。具体的RESTFul风格及其规范可参考这篇文章：理解RESTful架构 总结一下什么是RESTful架构： 1.每一个URI代表一种资源； 2.客户端和服务器之间，传递这种资源的某种表现层； 3.客户端通过四个HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”。 常见误区： 1.URI包含动词 2.URI中加入版本号 下面我们重点讲解如何创建具有RESTFul风格的控制器一. 控制器生成 Laravel的资源控制器原生的支持了RESTful架构。其实laravel的资源控制器和其他控制器没什么直接区别，只是对控制器类的方法和结构略有规定，不过我们并不要手动创建资源控制器，我们可以利用laravel的命令行工具——artisan。 到laravel框架项目的根目录下，通过命令行输入命令： php artisan make:controller MyTestController 注意:在laravel5.1中用php artisan生成的控制器会有默认的方法index、create、show、edit…等等;如果不需要默认的方法，可以通过命令行输入命令： php artisan make:controller MyTestController –plain laravel5.2以后生成控制器是默认没有index、create、show、edit..等几个方法的，如果想生成默认的方法 可以在laravel框架根目录下，通过命令行输入命令 php artisan make:controller MyTestController –resource 就可以创建一个名为MyTestController的资源控制器，文件默认在app/Http/Controllers下。我们打开MyTestController.php，发现里面已经写好了许多方法，比如index、create、show等等。分别是什么意思？如何在路由定义才能访问到？ 我们如果要在路由里定义一个资源控制器只需要一条：1Route::resource(&apos;/test&apos;, &apos;MyTestController&apos;); 二 .下面介绍下RESTful的跳转规则:12345678910111213141516171819202122232425262728293031323334请求URL: /test 请求方式:GET 默认进入控制器的方法:index() 一般用于:页面展示/列表展示请求URL: /test/creation请求方式:GET 默认进入控制器的方法:create() 一般用于:添加/新建请求URL: /test 请求方式:POST 默认进入控制器的方法:store()请求URL: /test/&#123;id&#125;/edit 例如: /test/1/edit请求方式:GET 默认进入控制器的方法:edit($id)一般用于:修改页面请求URL: /test/&#123;id&#125; 请求方式:PUT PUT方法需要定义一个隐藏表单 &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;PUT&quot;/&gt; 默认进入控制器的方法:update($id)一般用于:接收修改的方法请求URL: /test/&#123;id&#125; 请求方式:GET 默认进入控制器的方法:show($id)一般用于:XX详情请求URL: /test/&#123;id&#125; 请求方式:DELETE PUT方法需要定义一个隐藏表单1&lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;DELETE&quot;/&gt; 默认进入控制器的方法:destroy($id)一般用于:删除备注：{id}是一个变动的数字,delete()使用要慎用，一般不会去删除数据库数据，而是通过将数据的状态进行修改以此来区分是否删除。 表单伪造 HTML 表单不支持 PUT、PATCH 或者 DELETE 请求方法，因此，当定义 PUT、PATCH 或 DELETE 路由时，需要添加一个隐藏的 _method 字段到表单中，其值被用作该表单的 HTTP 请求方法： 1234&lt;form action=&quot;/foo/bar&quot; method=&quot;POST&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;PUT&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;_token&quot; value=&quot;&#123;&#123; csrf_token() &#125;&#125;&quot;&gt;&lt;/form&gt; 大概举两条解释。 我定义了个资源路由 1Route::resource(&apos;/test&apos;, &apos;MyTestController&apos;); 当我访问地址http://www.liutao1995.top/test，相当于访问控制器MyTestController的index方法。 当我访问地址http://www.liutao1995.top/test/creation，就会访问到create方法。 当我通过POST提交数据至地址http://www.liutao1995.top/test，相当于由store方法处理。 现在理解了吗？通过资源控制器，我们很容易实现一个符合RESTful架构的接口，这种很适合作为APP后端开发时使用。这种规范下，不但访问策略清晰易理解，更容易维护。也使你的架构更为合理和现代化。 简单举例如果在路由中全部定义 Route::get(&apos;/test&apos;, &apos;MyTestController&apos;); Route::post(&apos;/test&apos;, &apos;MyTestController&apos;); Route::get(&apos;/testEdit&apos;, &apos;MyTestController@edit&apos;); Route::post(&apos;/testUp&apos;, &apos;MyTestController@up&apos;); Route::controller(&apos;/addTest&apos;,&apos;MyTestController&apos;); 和Restful写法(写一个路由可以包含很多种动作,当然有些特定方法不够用的时候也得指定方法)会让臃肿的路由更加简易 Route::resource(&apos;/test&apos;, &apos;TestController&apos;); Route::resource(&apos;/test_blog&apos;, &apos;TestController@blog&apos;);]]></content>
  </entry>
  <entry>
    <title><![CDATA[LAMP 服务器搭建 ubuntu 16.04 篇]]></title>
    <url>%2F2017%2F07%2F24%2Flinux-ubuntu%2F</url>
    <content type="text"><![CDATA[1. 更新源sudo apt-get update 2. Apache2 安装sudo apt-get install apache2 查看状态： service apache2 status/start/stop/restart Web目录： /var/www安装目录： /etc/apache2/ 全局配置： /etc/apache2/apache2.conf 监听端口： /etc/apache2/ports.conf 虚拟主机： /etc/apache2/sites-enabled/000-default.conf &amp;测试 在浏览器中输入：http://localhost或http：//127.0.0.1，可以看到下图： 3. PHP安装&amp;安装代码sudo apt-get install php7.0 // ubuntu16.04中没有php5了，直接装7吧 sudo apt-get install libapache2-mod-php7.0 // 配置APACHE+PHP7的 sudo /etc/init.d/apache2 restart // 重启 测试php文件在你的目录下建一个 test.php输入代码，然后浏览器输入对应文件夹名字可以看到如下图phpinfo(); 4. MySql 安装&amp;安装代码sudo apt-get install mysql-server mysql-client // 安装时会要求输入mysql管理员密码，输入即可 常用软件 安装1. SSHsudo apt-get installr openssh-server 2. Vimsudo apt-get installr vim 3. gitsudo apt-get installr git]]></content>
  </entry>
  <entry>
    <title><![CDATA[HTML < marquee > 标签实现滚动效果]]></title>
    <url>%2F2017%2F07%2F24%2Fmarquee%2F</url>
    <content type="text"><![CDATA[今天无意中发现了html 标签如此强大. 可以实现多种滚动效果，更本无需js控制。 使用marquee标记不仅可以移动文字，还可以移动图片，等等…… 语法:&lt; marquee &gt;…&lt; /marquee &gt;； 说明: 在标记之间添加要进行滚动的内容。重要属性: 1.滚动方向 direction属性（包括4个值:up、 down、 left和 right） 12语法：&lt;marquee direction=&quot;滚动方向&quot;&gt;...&lt;/marquee&gt; 2.滚动方式 属性: behavior 属性值: scroll:循环滚动，默认效果； 属性值:slide:只滚动一次就停止； 属性值: alternate:来回交替进行滚动） 12语法：&lt;marquee behavior=&quot;滚动方式&quot;&gt;...&lt;/marquee&gt; 3.滚动速度 属性:scrollamount（滚动速度是设置每次滚动时移动的长度，以像素为单位） 12 语法：&lt;marquee scrollamount=&quot;5&quot;&gt;...&lt;/marquee&gt; 4.滚动延迟scrolldelay（设置滚动的时间间隔，单位是毫秒） 12 语法：&lt;marquee scrolldelay=&quot;100&quot;&gt;...&lt;/marquee&gt; 5.滚动循环 属性:loop（默认值是-1，滚动会不断的循环下去） 12语法: marquee loop=&quot;2&quot;&gt;...&lt;/marquee&gt; 6.滚动范围width、height 7.滚动背景颜色bgcolor 8.空白空间hspace、vspace]]></content>
  </entry>
  <entry>
    <title><![CDATA[Atom 编辑器 Markdown书写快捷键]]></title>
    <url>%2F2017%2F07%2F24%2Fatome-kj%2F</url>
    <content type="text"><![CDATA[概述Markdown 的目标是实现「易读易写」。 Markdown 的语法全由一些符号所组成，这些符号经过精挑细选，其作用一目了然。比如：在文字两旁加上星号，看起来就像强调。Markdown 的列表看起来，嗯，就是列表。Markdown 的区块引用看起来就真的像是引用一段文字，就像你曾在电子邮件中见过的那样。 加粗文字 : b 代码: c 斜体: i 图像: img 链接: l 版权声明: legal 填充文字: lorem 引用编号代码格式:ref 外联引用指定编号的链接: rl 外联引用指定编号图片: rimg todo列表 :t 表格： table 注意请安装autocomplete-plus插件，安装方式请参考 ATOM推荐插件]]></content>
  </entry>
  <entry>
    <title><![CDATA[Sass的表达式和控制命令 @for 篇]]></title>
    <url>%2F2017%2F07%2F24%2Fsass-2%2F</url>
    <content type="text"><![CDATA[@for@for指令常用于循环输出。 @for 有两种使用方式:from start through end和from start to end,两者的区别在于，前者遍历的范围是 [start, end], 而后者的遍历范围是 [start, end-1]。在@for循环中使用一个固定变量来替代遍历到的元素。如果你想实现从大到小的遍历，只需让 start 大于 end 即可。或者可以这样来理解 123456789@for $i from &lt;start&gt; through &lt;end&gt;@for $i from &lt;start&gt; to &lt;end&gt; $i 表示变量 start 表示起始值 end 表示结束值 这两个的区别是关键字through表示包括end这个数，而to则不包括end这个数。 从 &lt;start&gt; 开始循环，到 &lt;end&gt; 结束 给个例子理解下!: through:1234@for $i from 1 through 3&#123; .item-#&#123;$i&#125; &#123;width: 2em * $i;&#125;&#125; 编译结果如下: 123456789.item-1 &#123; width: 2em; &#125;.item-2 &#123; width: 4em; &#125;.item-3 &#123; width: 6em; &#125; 从 start开始（此处示例是1），一直遍历到 end (此处示例是3) 包括end的值。 to: 123@for $i from 1 to 3&#123; .item-#&#123;$i&#125;&#123;width: 2em * $i;&#125;&#125; 编译结果如下:123456.items-1 &#123; width: 2em; &#125;.items-2 &#123; width: 4em; &#125; 循环从 start开始，一直遍历循环到end 结束。这种形式的循环只要碰到 end 就会停止循环（将不会遍历end 值）。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Sass的表达式和控制命令 if篇]]></title>
    <url>%2F2017%2F07%2F24%2Fsass-1%2F</url>
    <content type="text"><![CDATA[if()if() 是 Sass 的一个内建函数，与之相似的 @if 则是一个内建指令。if() 用来做条件判断并返回特定值，示例如下:123456789101112@mixin test($condition)&#123; $color: if($condition,blue,red); color:$color;&#125;.First&#123; @include test(true);&#125;.Second&#123; @include test(false);&#125; 编译结果为: 123456.First &#123; color: blue; &#125;.Second &#123; color: red; &#125; 在上面的例字中，if() 函数内的三个参数分别代表: 测试条件，测试成功返回值，测试失败返回值\（除了 false 和 null 之外的所有测试条件都被视为测试成功）。如果使用数字作为上述示例的条件，同样会返回测试成功的值: @if@if 后跟一个表达式，如果表达式的结果为 true，则返回特定的样式，示例如下: 12345678910111213@mixin txt($weight) &#123; color: white; @if $weight == bold &#123; font-weight: bold;&#125;&#125;.txt1 &#123; @include txt(none);&#125;.txt2 &#123; @include txt(bold);&#125; 编译结果为:1234567.txt1 &#123; color: white; &#125;.txt2 &#123; color: white; font-weight: bold; &#125; 此外，我们可以使用 @if … @else if … @else 结构来处理多个条件，示例如下： 1234567891011121314151617181920212223@mixin txt($weight) &#123; color: white; @if $weight == bold &#123; font-weight: bold;&#125; @else if $weight == light &#123; font-weight: 100;&#125; @else &#123; font-weight: normal;&#125;&#125;.txt1 &#123; @include txt(bold);&#125;.txt2 &#123; @include txt(light);&#125;.txt3 &#123; @include txt(none);&#125;.txt4 &#123; @include txt(normal)&#125; 编译结果如下:12345678910111213141516.txt1 &#123; color: white; font-weight: bold; &#125;.txt2 &#123; color: white; font-weight: 100; &#125;.txt3 &#123; color: white; font-weight: normal; &#125;.txt4 &#123; color: white; font-weight: normal; &#125; 这里的 .txt3 和 .txt4 是用来向各位演示 @if 的解析机制。在 .txt1 中，如果不传入 bold，那么就不会生成 font-weight 相关的样式。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Sass的表达式和控制命令 @each 篇 + @while 篇]]></title>
    <url>%2F2017%2F07%2F24%2Fsass-3%2F</url>
    <content type="text"><![CDATA[@each指令形式:@each 指令同样可以用于循环输出，和 @for 的差别在于，@each 通过遍历 list 或者 map 实现循环输出: list: 指列表 map: 可以包含若干值的对象类型,使用()包围一个map，里面的键值用逗号隔开，键和值可以是任何的Sass数据类型，尽管一个值可以用在多个键上，但是通过一个键我们必须只能找到一个值。注: map不能直接在css中使用,如果把一个map赋值给一个元素会报错。 奉上一段例子! list: 123456@each $usr in a, b, c, d &#123; .#&#123;$usr&#125;-images &#123; background-image: url(&apos;/img/#&#123;$usr&#125;.png&apos;); &#125;&#125; @each 后面的 $usr 变量用于保存每次遍历到的元素，然后使用差值语法（#{var}）来拼接正确的图片路径编译后的结果: 123456789101112.a-images &#123; background-image: url(&quot;/img/a.png&quot;); &#125;.b-images &#123; background-image: url(&quot;/img/b.png&quot;); &#125;.c-images &#123; background-image: url(&quot;/img/c.png&quot;); &#125;.d-images &#123; background-image: url(&quot;/img/d.png&quot;); &#125; 如果遍历的对象是 一个 map，那么我们就可以使用两个变量来存储元素的 key 和 value，示例如下： 12345678$params: ( usr1:a, usr2:b, usr3:c, usr4:d );@each $key, $usr in $params &#123; .#&#123;$usr&#125;-images &#123; background-image: url(&apos;/img/#&#123;$usr&#125;.png&apos;); &#125;&#125; 此外，针对多个列表的遍历，我们也可以使用多个参数来保存相应的元素: 12345678910111213$alt: alert, yellow, red;$sub: submit, white, green;$bck: back, blue, transparent;@each $type, $txt, $back in $alt,$sub,$bck &#123; .#&#123;$type&#125;-button &#123; color: $txt; background-color: $back; &#125;&#125; 编译结果如下: 123456789101112.alert-button &#123; color: yellow; background-color: red; &#125;.submit-button &#123; color: white; background-color: green; &#125;.back-button &#123; color: blue; background-color: transparent; &#125; @while指令@while 指令也可以用于循环输出，它后面跟一个表达式，如果表达式结果为 false，则停止循环体。123456$x:1;@while $x &lt; 5 &#123; .col-#&#123;$x&#125; &#123; width: 100/4 * $x +px;&#125; $x: $x + 1;&#125;; 编译结果为:123456789101112.col-1 &#123; width: 25px; &#125;.col-2 &#123; width: 50px; &#125;.col-3 &#123; width: 75px; &#125;.col-4 &#123; width: 100px; &#125; 我们用一个表达式来控制 @while 指令的执行，表达式中有一个变量 $x，该变量一方面用于插值计算，另一方面在循环体内执行累加，最终当 $x &lt; 13 的结果为 false 时，程序就会推出 @while 循环]]></content>
  </entry>
  <entry>
    <title><![CDATA[如何在laravel 项目中运用基于bootstrap Sass文件结构 编译自己的Sass文件]]></title>
    <url>%2F2017%2F07%2F24%2Fsass-4%2F</url>
    <content type="text"><![CDATA[首先进入bootstrap官网 下载bootstrap Sass链接 如图: 下载好以后解压完目录: 我们只需要吧 assets 这个目录放到项目public下面,文件目录结构图: 然后点开 stylesheets 文件夹,我们会看到文件夹名字前面都有 _ 下划线这么一个梗, 代表文件不能被编译,好我们继续往下看,bootstrap sass 结构 在 /assets/stylesheet/中，bootstrap文件夹和bootstrap.scss,bootstrap-compass都是我们核心文件。点开_bootstrap.scss文件 我们会看到以下目录 /*! * Bootstrap v3.3.7 (http://getbootstrap.com) * Copyright 2011-2016 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE) */ // Core variables and mixins @import "bootstrap/variables"; @import "bootstrap/mixins"; // Reset and dependencies @import "bootstrap/normalize"; @import "bootstrap/print"; @import "bootstrap/glyphicons"; // Core CSS @import "bootstrap/scaffolding"; @import "bootstrap/type"; @import "bootstrap/code"; @import "bootstrap/grid"; @import "bootstrap/tables"; @import "bootstrap/forms"; @import "bootstrap/buttons"; // Components @import "bootstrap/component-animations"; @import "bootstrap/dropdowns"; @import "bootstrap/button-groups"; @import "bootstrap/input-groups"; @import "bootstrap/navs"; @import "bootstrap/navbar"; @import "bootstrap/breadcrumbs"; @import "bootstrap/pagination"; @import "bootstrap/pager"; @import "bootstrap/labels"; @import "bootstrap/badges"; @import "bootstrap/jumbotron"; @import "bootstrap/thumbnails"; @import "bootstrap/alerts"; @import "bootstrap/progress-bars"; @import "bootstrap/media"; @import "bootstrap/list-group"; @import "bootstrap/panels"; @import "bootstrap/responsive-embed"; @import "bootstrap/wells"; @import "bootstrap/close"; // Components w/ JavaScript @import "bootstrap/modals"; @import "bootstrap/tooltip"; @import "bootstrap/popovers"; @import "bootstrap/carousel"; // Utility classes @import "bootstrap/utilities"; @import "bootstrap/responsive-utilities"; 注! 不要再bootstrap 文件下写自己的scss文件,可以再同级下创建一个文件夹如:myselfBooStrap，从而编写自己的scss文件 1.编写自己的scss 文件前缀要和bootstrap一样,统一加上下划线如 _demo.scss. 2.我们编写完sass代码，如何引入呢? 如下:加入一条关键性代码. @import “myselfBooStrap/demo”; 3.然而还没完,仔细看 stylesheets 下的scss文件前面也有下划线,ok.把项目文件名前的去掉 4.Sass 编译命令 : sass 编译的文件名 (编译路径)编译的文件名 (命令如下) sass bootstrap.min.scss ../css/bootstrap.min.css 5.现在就有个疑问了,我每次编写代码,每次都得输一次命令吗? No 不需要, 文件自动监听,上代码: sass --watch bootstrap.min.ss:../css/bootstrap.min.css ok ！ 尽情的享受sass 带来的。。。。 有不足之处,还望各位老铁提出宝贵的意见! 抱拳了!!认真脸]]></content>
  </entry>
  <entry>
    <title><![CDATA[调用新浪接口查询IP地址]]></title>
    <url>%2F2017%2F07%2F24%2Fxinlang%2F</url>
    <content type="text"><![CDATA[新浪IP接口查询代码: var i=remote_ip_info; document.write('IP范围:' + i['ret'] + i['start'] +'-'+i['end'] + '\r\n归属地:' + i['country'] + i['province'] + i['city'] + i['isp']); ``` 1 183.128.0.0 183.129.255.255 中国 浙江 杭州 电信或者 1 -1 -1 中国 浙江 杭州 第一个数字 1表示正常 -1表示内网，-2表示ip地址输入有误 第二和第三个字段 表示这一段内的ip都是对应相同的ip地址信息 第四个字段 表示所在国家 第五个字段 表示所在省 第六个字段 表示所在城市 第七个字段 表示网络所属运营商]]></content>
  </entry>
</search>